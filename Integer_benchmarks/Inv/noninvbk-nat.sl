(set-logic LIA)
(declare-var invalid Int)
(declare-var unowned Int)
(declare-var nonexclusive Int)
(declare-var exclusive Int)
(declare-var RETURN Int)
(declare-var invalid! Int)
(declare-var unowned! Int)
(declare-var nonexclusive! Int)
(declare-var exclusive! Int)
(declare-var RETURN! Int)
(synth-fun inv-f((parameter0 Int)(parameter1 Int)(parameter2 Int)(parameter3 Int)(parameter4 Int))Bool) 
(constraint (=> (and (ite (>= invalid 1) (= RETURN 0) (= RETURN 1)) (ite (= unowned 0) (= RETURN 0) (= RETURN 1)) (ite (= nonexclusive 0) (= RETURN 0) (= RETURN 1)) (ite (= exclusive 0) (= RETURN 0) (= RETURN 1)) )(inv-f invalid unowned nonexclusive exclusive RETURN )))
(constraint (=> (and (inv-f invalid unowned nonexclusive exclusive RETURN ) (or (and (ite (not (>= invalid 1)) (= RETURN! 1) (= RETURN! RETURN)) (= nonexclusive! (+ nonexclusive exclusive )) (= exclusive! 0) (= invalid! (- invalid 1)) (= unowned! (+ unowned 1 )) ) (and (ite (not (>= (+ nonexclusive unowned ) 1)) (= RETURN! 1) (= RETURN! RETURN)) (= nonexclusive! 0) (= exclusive! (+ exclusive 1 )) (= invalid! (- (+ invalid unowned nonexclusive ) 1)) (= unowned! 0) ) (and (ite (not (>= invalid 1)) (= RETURN! 1) (= RETURN! RETURN)) (= nonexclusive! 0) (= exclusive! 1) (= invalid! (- (+ invalid unowned! exclusive! nonexclusive! ) 1)) (= unowned! 0) ) ) )(inv-f invalid! unowned! nonexclusive! exclusive! RETURN! )))
(constraint (=> (inv-f invalid unowned nonexclusive exclusive RETURN )(=> (= RETURN 0)(and (>= exclusive 0) (>= nonexclusive 0) (>= unowned 0) (>= invalid 0) (>= (+ invalid unowned exclusive ) 1) ))))
(check-synth)

