(set-logic LIA)
(declare-var d1 Int)
(declare-var d1! Int)
(declare-var d2 Int)
(declare-var d2! Int)
(declare-var d3 Int)
(declare-var d3! Int)
(declare-var x1 Int)
(declare-var x1! Int)
(declare-var x2 Int)
(declare-var x2! Int)
(declare-var x3 Int)
(declare-var x3! Int)
(declare-var d1_0 Int)
(declare-var d1_0! Int)
(declare-var d2_0 Int)
(declare-var d2_0! Int)
(declare-var d3_0 Int)
(declare-var d3_0! Int)
(declare-var x1_0 Int)
(declare-var x1_0! Int)
(declare-var x1_1 Int)
(declare-var x1_1! Int)
(declare-var x1_2 Int)
(declare-var x1_2! Int)
(declare-var x1_3 Int)
(declare-var x1_3! Int)
(declare-var x2_0 Int)
(declare-var x2_0! Int)
(declare-var x2_1 Int)
(declare-var x2_1! Int)
(declare-var x2_2 Int)
(declare-var x2_2! Int)
(declare-var x2_3 Int)
(declare-var x2_3! Int)
(declare-var x3_0 Int)
(declare-var x3_0! Int)
(declare-var x3_1 Int)
(declare-var x3_1! Int)
(declare-var x3_2 Int)
(declare-var x3_2! Int)
(declare-var x3_3 Int)
(declare-var x3_3! Int)
(synth-fun inv-f((parameter0 Int)(parameter1 Int)(parameter2 Int)(parameter3 Int)(parameter4 Int)(parameter5 Int)(parameter6 Int)(parameter7 Int)(parameter8 Int)(parameter9 Int)(parameter10 Int)(parameter11 Int)(parameter12 Int)(parameter13 Int)(parameter14 Int)(parameter15 Int)(parameter16 Int)(parameter17 Int)(parameter18 Int)(parameter19 Int)(parameter20 Int))Bool) 
(constraint (=> (and (= d1 d1_0) (= d2 d2_0) (= d3 d3_0) (= x1 x1_0) (= d1_0 1) (= d2_0 1) (= d3_0 1) (= x1_0 1) )(inv-f d1 d2 d3 x1 x2 x3 d1_0 d2_0 d3_0 x1_0 x1_1 x1_2 x1_3 x2_0 x2_1 x2_2 x2_3 x3_0 x3_1 x3_2 x3_3 )))
(constraint (=> (and (inv-f d1 d2 d3 x1 x2 x3 d1_0 d2_0 d3_0 x1_0 x1_1 x1_2 x1_3 x2_0 x2_1 x2_2 x2_3 x3_0 x3_1 x3_2 x3_3 ) (or (and (= x1_1 x1) (= x2_1 x2) (= x3_1 x3) (= x1_1 x1!) (= x2_1 x2!) (= x3_1 x3!) (= d1 d1!) (= d2 d2!) (= d3 d3!) (= x2 x2!) (= x3 x3!) ) (and (= x1_1 x1) (= x2_1 x2) (= x3_1 x3) (> x1_1 0) (> x2_1 0) (> x3_1 0) (= x1_2 (- x1_1 d1_0)) (= x2_2 (- x2_1 d2_0)) (= x3_2 (- x3_1 d3_0)) (= x1_3 x1_2) (= x2_3 x2_2) (= x3_3 x3_2) (= x1_3 x1!) (= x2_3 x2!) (= x3_3 x3!) (= d1 d1_0) (= d1! d1_0) (= d2 d2_0) (= d2! d2_0) (= d3 d3_0) (= d3! d3_0) ) (and (= x1_1 x1) (= x2_1 x2) (= x3_1 x3) (> x1_1 0) (> x2_1 0) (not (> x3_1 0)) (= x1_3 x1_1) (= x2_3 x2_1) (= x3_3 x3_1) (= x1_3 x1!) (= x2_3 x2!) (= x3_3 x3!) (= d1 d1_0) (= d1! d1_0) (= d2 d2_0) (= d2! d2_0) (= d3 d3_0) (= d3! d3_0) ) (and (= x1_1 x1) (= x2_1 x2) (= x3_1 x3) (> x1_1 0) (not (> x2_1 0)) (= x1_3 x1_1) (= x2_3 x2_1) (= x3_3 x3_1) (= x1_3 x1!) (= x2_3 x2!) (= x3_3 x3!) (= d1 d1_0) (= d1! d1_0) (= d2 d2_0) (= d2! d2_0) (= d3 d3_0) (= d3! d3_0) ) ) )(inv-f d1! d2! d3! x1! x2! x3! d1_0! d2_0! d3_0! x1_0! x1_1! x1_2! x1_3! x2_0! x2_1! x2_2! x2_3! x3_0! x3_1! x3_2! x3_3! )))
(constraint (=> (inv-f d1 d2 d3 x1 x2 x3 d1_0 d2_0 d3_0 x1_0 x1_1 x1_2 x1_3 x2_0 x2_1 x2_2 x2_3 x3_0 x3_1 x3_2 x3_3 )(or (not (and (= d1 d1_0) (= d2 d2_0) (= d3 d3_0) (= x1 x1_1) (= x2 x2_1) (= x3 x3_1) )) (not (and (not (> x1_1 0)) (not (>= x2_1 0)) )) )))
(check-synth)

